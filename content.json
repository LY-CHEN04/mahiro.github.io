{"meta":{"title":"OYAMAMahiro","subtitle":"","description":"2024-08-22","author":"CLY","url":"https://ly-chen04.github.io","root":"/"},"pages":[{"title":"tags","date":"2024-09-05T03:35:33.000Z","updated":"2024-09-05T03:35:33.551Z","comments":true,"path":"tags/index.html","permalink":"https://ly-chen04.github.io/tags/index.html","excerpt":"","text":""},{"title":"Blue Archive 相册","date":"2024-09-06T16:14:11.000Z","updated":"2024-09-06T16:39:33.434Z","comments":true,"path":"masonry/index.html","permalink":"https://ly-chen04.github.io/masonry/index.html","excerpt":"","text":""},{"title":"","date":"2024-09-06T17:22:43.035Z","updated":"2024-09-06T17:22:43.035Z","comments":true,"path":"games/index.html","permalink":"https://ly-chen04.github.io/games/index.html","excerpt":"","text":"切块 body { margin: 0; background-color: #000; background-image: radial-gradient(ellipse at top, #335476 0.0%, #31506e 11.1%, #304b67 22.2%, #2f4760 33.3%, #2d4359 44.4%, #2c3f51 55.6%, #2a3a4a 66.7%, #293643 77.8%, #28323d 88.9%, #262e36 100.0%); height: 100vh; overflow: hidden; font-family: MiSans; sans-serif font-weight: normal; font-weight: 200; letter-spacing: 0.06em; color: rgba(255, 255, 255, 0.75); } #c { display: block; touch-action: none; transform: translateZ(0); } /*///////////////////// // HUD // /////////////////////*/ .hud__score, .pause-btn { position: fixed; font-size: calc(14px + 2vw + 1vh); } .hud__score { top: 0.65em; left: 0.65em; pointer-events: none; user-select: none; } .cube-count-lbl { font-size: 0.46em; } .pause-btn { position: fixed; top: 0; right: 0; padding: 0.8em 0.65em; } .pause-btn > div { position: relative; width: 0.8em; height: 0.8em; opacity: 0.75; } .pause-btn > div::before, .pause-btn > div::after { content: ''; display: block; width: 34%; height: 100%; position: absolute; background-color: #fff; } .pause-btn > div::after { right: 0; } .slowmo { position: fixed; bottom: 0; width: 100%; pointer-events: none; opacity: 0; transition: opacity 0.4s; will-change: opacity; } .slowmo::before { content: 'SLOW-MO'; display: block; font-size: calc(8px + 1vw + 0.5vh); margin-left: 0.5em; margin-bottom: 8px; } .slowmo::after { content: ''; display: block; position: fixed; bottom: 0; width: 100%; height: 1.5vh; background-color: rgba(0, 0, 0, 0.25); z-index: -1; } .slowmo__bar { height: 1.5vh; background-color: rgba(255, 255, 255, 0.75); transform-origin: 0 0; } /*///////////////////// // MENUS // /////////////////////*/ .menus::before { content: ''; pointer-events: none; position: fixed; top: 0; right: 0; bottom: 0; left: 0; background-color: #000; opacity: 0; transition: opacity 0.2s; transition-timing-function: ease-in; } .menus.has-active::before { opacity: 0.08; transition-duration: 0.4s; transition-timing-function: ease-out; } .menus.interactive-mode::before { opacity: 0.02; } /* Menu containers */ .menu { pointer-events: none; position: fixed; top: 0; right: 0; bottom: 0; left: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; user-select: none; text-align: center; color: rgba(255, 255, 255, 0.9); opacity: 0; visibility: hidden; transform: translateY(30px); transition-property: opacity, visibility, transform; transition-duration: 0.2s; transition-timing-function: ease-in; } .menu.active { opacity: 1; visibility: visible; transform: translateY(0); transition-duration: 0.4s; transition-timing-function: ease-out; } .menus.interactive-mode .menu.active { opacity: 0.6; } .menus:not(.interactive-mode) .menu.active > * { pointer-events: auto; } /* Common menu elements */ h1 { font-size: 4rem; line-height: 0.95; text-align: center; font-weight: bold; margin: 0 0.65em 1em; } h2 { font-size: 1.2rem; line-height: 1; text-align: center; font-weight: bold; margin: -1em 0.65em 1em; } .final-score-lbl { font-size: 5rem; margin: -0.2em 0 0; } .high-score-lbl { font-size: 1.2rem; margin: 0 0 2.5em; } button { display: block; position: relative; width: 200px; padding: 12px 20px; background: transparent; border: none; outline: none; user-select: none; font-family: monospace; font-weight: bold; font-size: 1.4rem; color: #fff; opacity: 0.75; transition: opacity 0.3s; } button::before { content: ''; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: rgba(255, 255, 255, 0.15); transform: scale(0, 0); opacity: 0; transition: opacity 0.3s, transform 0.3s; } /* No `:focus` styles because this is a mouse/touch game! */ button:active { opacity: 1; } button:active::before { transform: scale(1, 1); opacity: 1; } .credits { position: fixed; width: 100%; left: 0; bottom: 20px; } a { color: white; } /* Only enable hover state on large screens */ @media (min-width: 1025px) { button:hover { opacity: 1; } button:hover::before { transform: scale(1, 1); opacity: 1; } } OYAMAMahiro ？水果忍者？ 开始游戏 随便玩玩 如要退出请通过浏览器导航返回 .pause 暂停 继续 不玩了 游戏结束 你的得分: 再来 离开 // globalConfig.js // ============================================================================ // ============================================================================ // Provides global variables used by the entire program. // Most of this should be configuration. // Timing multiplier for entire game engine. let gameSpeed = 1; // Colors const BLUE = { r: 0x67, g: 0xd7, b: 0xf0 }; const GREEN = { r: 0xa6, g: 0xe0, b: 0x2c }; const PINK = { r: 0xfa, g: 0x24, b: 0x73 }; const ORANGE = { r: 0xfe, g: 0x95, b: 0x22 }; const allColors = [BLUE, GREEN, PINK, ORANGE]; // Gameplay const getSpawnDelay = () => { const spawnDelayMax = 1400; const spawnDelayMin = 550; const spawnDelay = spawnDelayMax - state.game.cubeCount * 3.1; return Math.max(spawnDelay, spawnDelayMin); } const doubleStrongEnableScore = 2000; // Number of cubes that must be smashed before activating a feature. const slowmoThreshold = 10; const strongThreshold = 25; const spinnerThreshold = 25; // Interaction state let pointerIsDown = false; // The last known position of the primary pointer in screen coordinates.` let pointerScreen = { x: 0, y: 0 }; // Same as `pointerScreen`, but converted to scene coordinates in rAF. let pointerScene = { x: 0, y: 0 }; // Minimum speed of pointer before \"hits\" are counted. const minPointerSpeed = 60; // The hit speed affects the direction the target post-hit. This number dampens that force. const hitDampening = 0.1; // Backboard receives shadows and is the farthest negative Z position of entities. const backboardZ = -400; const shadowColor = '#262e36'; // How much air drag is applied to standard objects const airDrag = 0.022; const gravity = 0.3; // Spark config const sparkColor = 'rgba(170,221,255,.9)'; const sparkThickness = 2.2; const airDragSpark = 0.1; // Track pointer positions to show trail const touchTrailColor = 'rgba(170,221,255,.62)'; const touchTrailThickness = 7; const touchPointLife = 120; const touchPoints = []; // Size of in-game targets. This affects rendered size and hit area. const targetRadius = 40; const targetHitRadius = 50; const makeTargetGlueColor = target => { // const alpha = (target.health - 1) / (target.maxHealth - 1); // return `rgba(170,221,255,${alpha.toFixed(3)})`; return 'rgb(170,221,255)'; }; // Size of target fragments const fragRadius = targetRadius / 3; // Game canvas element needed in setup.js and interaction.js const canvas = document.querySelector('#c'); // 3D camera config // Affects perspective const cameraDistance = 900; // Does not affect perspective const sceneScale = 1; // Objects that get too close to the camera will be faded out to transparent over this range. // const cameraFadeStartZ = 0.8*cameraDistance - 6*targetRadius; const cameraFadeStartZ = 0.45*cameraDistance; const cameraFadeEndZ = 0.65*cameraDistance; const cameraFadeRange = cameraFadeEndZ - cameraFadeStartZ; // Globals used to accumlate all vertices/polygons in each frame const allVertices = []; const allPolys = []; const allShadowVertices = []; const allShadowPolys = []; // state.js // ============================================================================ // ============================================================================ /////////// // Enums // /////////// // Game Modes const GAME_MODE_RANKED = Symbol('GAME_MODE_RANKED'); const GAME_MODE_CASUAL = Symbol('GAME_MODE_CASUAL'); // Available Menus const MENU_MAIN = Symbol('MENU_MAIN'); const MENU_PAUSE = Symbol('MENU_PAUSE'); const MENU_SCORE = Symbol('MENU_SCORE'); ////////////////// // Global State // ////////////////// const state = { game: { mode: GAME_MODE_RANKED, // Run time of current game. time: 0, // Player score. score: 0, // Total number of cubes smashed in game. cubeCount: 0 }, menus: { // Set to `null` to hide all menus active: MENU_MAIN } }; //////////////////////////// // Global State Selectors // //////////////////////////// const isInGame = () => !state.menus.active; const isMenuVisible = () => !!state.menus.active; const isCasualGame = () => state.game.mode === GAME_MODE_CASUAL; const isPaused = () => state.menus.active === MENU_PAUSE; /////////////////// // Local Storage // /////////////////// const highScoreKey = '__menja__highScore'; const getHighScore = () => { const raw = localStorage.getItem(highScoreKey); return raw ? parseInt(raw, 10) : 0; }; const setHighScore = score => localStorage.setItem(highScoreKey, String(score)) // utils.js // ============================================================================ // ============================================================================ const invariant = (condition, message) => { if (!condition) throw new Error(message); }; ///////// // DOM // ///////// const $ = selector => document.querySelector(selector); const handleClick = (element, handler) => element.addEventListener('click', handler); const handlePointerDown = (element, handler) => { element.addEventListener('touchstart', handler); element.addEventListener('mousedown', handler); }; //////////////////////// // Formatting Helpers // //////////////////////// // Converts a number into a formatted string with thousand separators. const formatNumber = num => num.toLocaleString(); //////////////////// // Math Constants // //////////////////// const PI = Math.PI; const TAU = Math.PI * 2; const ETA = Math.PI * 0.5; ////////////////// // Math Helpers // ////////////////// // Clamps a number between min and max values (inclusive) const clamp = (num, min, max) => Math.min(Math.max(num, min), max); // Linearly interpolate between numbers a and b by a specific amount. // mix >= 0 && mix (b - a) * mix + a; //////////////////// // Random Helpers // //////////////////// // Generates a random number between min (inclusive) and max (exclusive) const random = (min, max) => Math.random() * (max - min) + min; // Generates a random integer between and possibly including min and max values const randomInt = (min, max) => ((Math.random() * (max - min + 1)) | 0) + min; // Returns a random element from an array const pickOne = arr => arr[Math.random() * arr.length | 0]; /////////////////// // Color Helpers // /////////////////// // Converts an { r, g, b } color object to a 6-digit hex code. const colorToHex = color => { return '#' + (color.r | 0).toString(16).padStart(2, '0') + (color.g | 0).toString(16).padStart(2, '0') + (color.b | 0).toString(16).padStart(2, '0'); }; // Operates on an { r, g, b } color object. // Returns string hex code. // `lightness` must range from 0 to 1. 0 is pure black, 1 is pure white. const shadeColor = (color, lightness) => { let other, mix; if (lightness < 0.5) { other = 0; mix = 1 - (lightness * 2); } else { other = 255; mix = lightness * 2 - 1; } return '#' + (lerp(color.r, other, mix) | 0).toString(16).padStart(2, '0') + (lerp(color.g, other, mix) | 0).toString(16).padStart(2, '0') + (lerp(color.b, other, mix) | 0).toString(16).padStart(2, '0'); }; //////////////////// // Timing Helpers // //////////////////// const _allCooldowns = []; const makeCooldown = (rechargeTime, units=1) => { let timeRemaining = 0; let lastTime = 0; const initialOptions = { rechargeTime, units }; const updateTime = () => { const now = state.game.time; // Reset time remaining if time goes backwards. if (now < lastTime) { timeRemaining = 0; } else { // update... timeRemaining -= now-lastTime; if (timeRemaining < 0) timeRemaining = 0; } lastTime = now; }; const canUse = () => { updateTime(); return timeRemaining cooldown.reset()); const makeSpawner = ({ chance, cooldownPerSpawn, maxSpawns }) => { const cooldown = makeCooldown(cooldownPerSpawn, maxSpawns); return { shouldSpawn() { return Math.random() { const mag = Math.hypot(v.x, v.y, v.z); return { x: v.x / mag, y: v.y / mag, z: v.z / mag }; } // Curried math helpers const add = a => b => a + b; // Curried vector helpers const scaleVector = scale => vector => { vector.x *= scale; vector.y *= scale; vector.z *= scale; }; //////////////// // 3D Helpers // //////////////// // Clone array and all vertices. function cloneVertices(vertices) { return vertices.map(v => ({ x: v.x, y: v.y, z: v.z })); } // Copy vertex data from one array into another. // Arrays must be the same length. function copyVerticesTo(arr1, arr2) { const len = arr1.length; for (let i=0; i { const targetVertex = target[i]; // X axis rotation const x1 = v.x; const y1 = v.z*sinX + v.y*cosX; const z1 = v.z*cosX - v.y*sinX; // Y axis rotation const x2 = x1*cosY - z1*sinY; const y2 = y1; const z2 = x1*sinY + z1*cosY; // Z axis rotation const x3 = x2*cosZ - y2*sinZ; const y3 = x2*sinZ + y2*cosZ; const z3 = z2; // Scale, Translate, and set the transform. targetVertex.x = x3 * sX + tX; targetVertex.y = y3 * sY + tY; targetVertex.z = z3 * sZ + tZ; }); } // 3D projection on a single vertex. // Directly mutates the vertex. const projectVertex = v => { const focalLength = cameraDistance * sceneScale; const depth = focalLength / (cameraDistance - v.z); v.x = v.x * depth; v.y = v.y * depth; }; // 3D projection on a single vertex. // Mutates a secondary target vertex. const projectVertexTo = (v, target) => { const focalLength = cameraDistance * sceneScale; const depth = focalLength / (cameraDistance - v.z); target.x = v.x * depth; target.y = v.y * depth; }; // PERF.js // ============================================================================ // ============================================================================ // Dummy no-op functions. // I use these in a special build for custom performance profiling. const PERF_START = () => {}; const PERF_END = () => {}; const PERF_UPDATE = () => {}; // 3dModels.js // ============================================================================ // ============================================================================ // Define models once. The origin is the center of the model. // A simple cube, 8 vertices, 6 quads. // Defaults to an edge length of 2 units, can be influenced with `scale`. function makeCubeModel({ scale=1 }) { return { vertices: [ // top { x: -scale, y: -scale, z: scale }, { x: scale, y: -scale, z: scale }, { x: scale, y: scale, z: scale }, { x: -scale, y: scale, z: scale }, // bottom { x: -scale, y: -scale, z: -scale }, { x: scale, y: -scale, z: -scale }, { x: scale, y: scale, z: -scale }, { x: -scale, y: scale, z: -scale } ], polys: [ // z = 1 { vIndexes: [0, 1, 2, 3] }, // z = -1 { vIndexes: [7, 6, 5, 4] }, // y = 1 { vIndexes: [3, 2, 6, 7] }, // y = -1 { vIndexes: [4, 5, 1, 0] }, // x = 1 { vIndexes: [5, 6, 2, 1] }, // x = -1 { vIndexes: [0, 3, 7, 4] } ] }; } // Not very optimized - lots of duplicate vertices are generated. function makeRecursiveCubeModel({ recursionLevel, splitFn, color, scale=1 }) { const getScaleAtLevel = level => 1 / (3 ** level); // We can model level 0 manually. It's just a single, centered, cube. let cubeOrigins = [{ x: 0, y: 0, z: 0 }]; // Recursively replace cubes with smaller cubes. for (let i=1; i { cubeOrigins2.push(...splitFn(origin, scale)); }); cubeOrigins = cubeOrigins2; } const finalModel = { vertices: [], polys: [] }; // Generate single cube model and scale it. const cubeModel = makeCubeModel({ scale: 1 }); cubeModel.vertices.forEach(scaleVector(getScaleAtLevel(recursionLevel))); // Compute the max distance x, y, or z origin values will be. // Same result as `Math.max(...cubeOrigins.map(o => o.x))`, but much faster. const maxComponent = getScaleAtLevel(recursionLevel) * (3 ** recursionLevel - 1); // Place cube geometry at each origin. cubeOrigins.forEach((origin, cubeIndex) => { // To compute occlusion (shading), find origin component with greatest // magnitude and normalize it relative to `maxComponent`. const occlusion = Math.max( Math.abs(origin.x), Math.abs(origin.y), Math.abs(origin.z) ) / maxComponent; // At lower iterations, occlusion looks better lightened up a bit. const occlusionLighter = recursionLevel > 2 ? occlusion : (occlusion + 0.8) / 1.8; // Clone, translate vertices to origin, and apply scale finalModel.vertices.push( ...cubeModel.vertices.map(v => ({ x: (v.x + origin.x) * scale, y: (v.y + origin.y) * scale, z: (v.z + origin.z) * scale })) ); // Clone polys, shift referenced vertex indexes, and compute color. finalModel.polys.push( ...cubeModel.polys.map(poly => ({ vIndexes: poly.vIndexes.map(add(cubeIndex * 8)) })) ); }); return finalModel; } // o: Vector3D - Position of cube's origin (center). // s: Vector3D - Determines size of menger sponge. function mengerSpongeSplit(o, s) { return [ // Top { x: o.x + s, y: o.y - s, z: o.z + s }, { x: o.x + s, y: o.y - s, z: o.z + 0 }, { x: o.x + s, y: o.y - s, z: o.z - s }, { x: o.x + 0, y: o.y - s, z: o.z + s }, { x: o.x + 0, y: o.y - s, z: o.z - s }, { x: o.x - s, y: o.y - s, z: o.z + s }, { x: o.x - s, y: o.y - s, z: o.z + 0 }, { x: o.x - s, y: o.y - s, z: o.z - s }, // Bottom { x: o.x + s, y: o.y + s, z: o.z + s }, { x: o.x + s, y: o.y + s, z: o.z + 0 }, { x: o.x + s, y: o.y + s, z: o.z - s }, { x: o.x + 0, y: o.y + s, z: o.z + s }, { x: o.x + 0, y: o.y + s, z: o.z - s }, { x: o.x - s, y: o.y + s, z: o.z + s }, { x: o.x - s, y: o.y + s, z: o.z + 0 }, { x: o.x - s, y: o.y + s, z: o.z - s }, // Middle { x: o.x + s, y: o.y + 0, z: o.z + s }, { x: o.x + s, y: o.y + 0, z: o.z - s }, { x: o.x - s, y: o.y + 0, z: o.z + s }, { x: o.x - s, y: o.y + 0, z: o.z - s } ]; } // Helper to optimize models by merging duplicate vertices within a threshold, // and removing all polys that share the same vertices. // Directly mutates the model. function optimizeModel(model, threshold=0.0001) { const { vertices, polys } = model; const compareVertices = (v1, v2) => ( Math.abs(v1.x - v2.x) < threshold && Math.abs(v1.y - v2.y) < threshold && Math.abs(v1.z - v2.z) < threshold ); const comparePolys = (p1, p2) => { const v1 = p1.vIndexes; const v2 = p2.vIndexes; return ( ( v1[0] === v2[0] || v1[0] === v2[1] || v1[0] === v2[2] || v1[0] === v2[3] ) && ( v1[1] === v2[0] || v1[1] === v2[1] || v1[1] === v2[2] || v1[1] === v2[3] ) && ( v1[2] === v2[0] || v1[2] === v2[1] || v1[2] === v2[2] || v1[2] === v2[3] ) && ( v1[3] === v2[0] || v1[3] === v2[1] || v1[3] === v2[2] || v1[3] === v2[3] ) ); }; vertices.forEach((v, i) => { v.originalIndexes = [i]; }); for (let i=vertices.length-1; i>=0; i--) { for (let ii=i-1; ii>=0; ii--) { const v1 = vertices[i]; const v2 = vertices[ii]; if (compareVertices(v1, v2)) { vertices.splice(i, 1); v2.originalIndexes.push(...v1.originalIndexes); break; } } } vertices.forEach((v, i) => { polys.forEach(p => { p.vIndexes.forEach((vi, ii, arr) => { const vo = v.originalIndexes; if (vo.includes(vi)) { arr[ii] = i; } }); }); }); polys.forEach(p => { const vi = p.vIndexes; p.sum = vi[0] + vi[1] + vi[2] + vi[3]; }); polys.sort((a, b) => b.sum - a.sum); // Assumptions: // 1. Each poly will either have no duplicates or 1 duplicate. // 2. If two polys are equal, they are both hidden (two cubes touching), // therefore both can be removed. for (let i=polys.length-1; i>=0; i--) { for (let ii=i-1; ii>=0; ii--) { const p1 = polys[i]; const p2 = polys[ii]; if (p1.sum !== p2.sum) break; if (comparePolys(p1, p2)) { polys.splice(i, 1); polys.splice(ii, 1); i--; break; } } } return model; } // Entity.js // ============================================================================ // ============================================================================ class Entity { constructor({ model, color, wireframe=false }) { const vertices = cloneVertices(model.vertices); const shadowVertices = cloneVertices(model.vertices); const colorHex = colorToHex(color); const darkColorHex = shadeColor(color, 0.4); const polys = model.polys.map(p => ({ vertices: p.vIndexes.map(vIndex => vertices[vIndex]), color: color, // custom rgb color object wireframe: wireframe, strokeWidth: wireframe ? 2 : 0, // Set to non-zero value to draw stroke strokeColor: colorHex, // must be a CSS color string strokeColorDark: darkColorHex, // must be a CSS color string depth: 0, middle: { x: 0, y: 0, z: 0 }, normalWorld: { x: 0, y: 0, z: 0 }, normalCamera: { x: 0, y: 0, z: 0 } })); const shadowPolys = model.polys.map(p => ({ vertices: p.vIndexes.map(vIndex => shadowVertices[vIndex]), wireframe: wireframe, normalWorld: { x: 0, y: 0, z: 0 } })); this.projected = {}; // Will store 2D projected data this.model = model; this.vertices = vertices; this.polys = polys; this.shadowVertices = shadowVertices; this.shadowPolys = shadowPolys; this.reset(); } // Better names: resetEntity, resetTransform, resetEntityTransform reset() { this.x = 0; this.y = 0; this.z = 0; this.xD = 0; this.yD = 0; this.zD = 0; this.rotateX = 0; this.rotateY = 0; this.rotateZ = 0; this.rotateXD = 0; this.rotateYD = 0; this.rotateZD = 0; this.scaleX = 1; this.scaleY = 1; this.scaleZ = 1; this.projected.x = 0; this.projected.y = 0; } transform() { transformVertices( this.model.vertices, this.vertices, this.x, this.y, this.z, this.rotateX, this.rotateY, this.rotateZ, this.scaleX, this.scaleY, this.scaleZ ); copyVerticesTo(this.vertices, this.shadowVertices); } // Projects origin point, stored as `projected` property. project() { projectVertexTo(this, this.projected); } } // getTarget.js // ============================================================================ // ============================================================================ // All active targets const targets = []; // Pool target instances by color, using a Map. // keys are color objects, and values are arrays of targets. // Also pool wireframe instances separately. const targetPool = new Map(allColors.map(c=>([c, []]))); const targetWireframePool = new Map(allColors.map(c=>([c, []]))); const getTarget = (() => { const slowmoSpawner = makeSpawner({ chance: 0.5, cooldownPerSpawn: 10000, maxSpawns: 1 }); let doubleStrong = false; const strongSpawner = makeSpawner({ chance: 0.3, cooldownPerSpawn: 12000, maxSpawns: 1 }); const spinnerSpawner = makeSpawner({ chance: 0.1, cooldownPerSpawn: 10000, maxSpawns: 1 }); // Cached array instances, no need to allocate every time. const axisOptions = [ ['x', 'y'], ['y', 'z'], ['z', 'x'] ]; function getTargetOfStyle(color, wireframe) { const pool = wireframe ? targetWireframePool : targetPool; let target = pool.get(color).pop(); if (!target) { target = new Entity({ model: optimizeModel(makeRecursiveCubeModel({ recursionLevel: 1, splitFn: mengerSpongeSplit, scale: targetRadius })), color: color, wireframe: wireframe }); // Init any properties that will be used. // These will not be automatically reset when recycled. target.color = color; target.wireframe = wireframe; // Some properties don't have their final value yet. // Initialize with any value of the right type. target.hit = false; target.maxHealth = 0; target.health = 0; } return target; } return function getTarget() { if (doubleStrong && state.game.score doubleStrongEnableScore) { doubleStrong = true; strongSpawner.mutate({ maxSpawns: 2 }); } // Target Parameters // -------------------------------- let color = pickOne([BLUE, GREEN, ORANGE]); let wireframe = false; let health = 1; let maxHealth = 3; const spinner = state.game.cubeCount >= spinnerThreshold && isInGame() && spinnerSpawner.shouldSpawn(); // Target Parameter Overrides // -------------------------------- if (state.game.cubeCount >= slowmoThreshold && slowmoSpawner.shouldSpawn()) { color = BLUE; wireframe = true; } else if (state.game.cubeCount >= strongThreshold && strongSpawner.shouldSpawn()) { color = PINK; health = 3; } // Target Creation // -------------------------------- const target = getTargetOfStyle(color, wireframe); target.hit = false; target.maxHealth = maxHealth; target.health = health; updateTargetHealth(target, 0); const spinSpeeds = [ Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05 ]; if (spinner) { // Ends up spinning a random axis spinSpeeds[0] = -0.25; spinSpeeds[1] = 0; target.rotateZ = random(0, TAU); } const axes = pickOne(axisOptions); spinSpeeds.forEach((spinSpeed, i) => { switch (axes[i]) { case 'x': target.rotateXD = spinSpeed; break; case 'y': target.rotateYD = spinSpeed; break; case 'z': target.rotateZD = spinSpeed; break; } }); return target; } })(); const updateTargetHealth = (target, healthDelta) => { target.health += healthDelta; // Only update stroke on non-wireframe targets. // Showing \"glue\" is a temporary attempt to display health. For now, there's // no reason to have wireframe targets with high health, so we're fine. if (!target.wireframe) { const strokeWidth = target.health - 1; const strokeColor = makeTargetGlueColor(target); for (let p of target.polys) { p.strokeWidth = strokeWidth; p.strokeColor = strokeColor; } } }; const returnTarget = target => { target.reset(); const pool = target.wireframe ? targetWireframePool : targetPool; pool.get(target.color).push(target); }; function resetAllTargets() { while(targets.length) { returnTarget(targets.pop()); } } // createBurst.js // ============================================================================ // ============================================================================ // Track all active fragments const frags = []; // Pool inactive fragments by color, using a Map. // keys are color objects, and values are arrays of fragments. // // Also pool wireframe instances separately. const fragPool = new Map(allColors.map(c=>([c, []]))); const fragWireframePool = new Map(allColors.map(c=>([c, []]))); const createBurst = (() => { // Precompute some private data to be reused for all bursts. const basePositions = mengerSpongeSplit({ x:0, y:0, z:0 }, fragRadius*2); const positions = cloneVertices(basePositions); const prevPositions = cloneVertices(basePositions); const velocities = cloneVertices(basePositions); const basePositionNormals = basePositions.map(normalize); const positionNormals = cloneVertices(basePositionNormals); const fragCount = basePositions.length; function getFragForTarget(target) { const pool = target.wireframe ? fragWireframePool : fragPool; let frag = pool.get(target.color).pop(); if (!frag) { frag = new Entity({ model: makeCubeModel({ scale: fragRadius }), color: target.color, wireframe: target.wireframe }); frag.color = target.color; frag.wireframe = target.wireframe; } return frag; } return (target, force=1) => { // Calculate fragment positions, and what would have been the previous positions // when still a part of the larger target. transformVertices( basePositions, positions, target.x, target.y, target.z, target.rotateX, target.rotateY, target.rotateZ, 1, 1, 1 ); transformVertices( basePositions, prevPositions, target.x - target.xD, target.y - target.yD, target.z - target.zD, target.rotateX - target.rotateXD, target.rotateY - target.rotateYD, target.rotateZ - target.rotateZD, 1, 1, 1 ); // Compute velocity of each fragment, based on previous positions. // Will write to `velocities` array. for (let i=0; i getHighScore()) { highScoreLblNode.textContent = 'New High Score!'; } else { highScoreLblNode.textContent = `High Score: ${formatNumber(getHighScore())}`; } showMenu(menuScoreNode); break; } setHudVisibility(!isMenuVisible()); menuContainerNode.classList.toggle('has-active', isMenuVisible()); menuContainerNode.classList.toggle('interactive-mode', isMenuVisible() && pointerIsDown); } renderMenus(); //////////////////// // Button Actions // //////////////////// // Main Menu handleClick($('.play-normal-btn'), () => { setGameMode(GAME_MODE_RANKED); setActiveMenu(null); resetGame(); }); handleClick($('.play-casual-btn'), () => { setGameMode(GAME_MODE_CASUAL); setActiveMenu(null); resetGame(); }); // Pause Menu handleClick($('.resume-btn'), () => resumeGame()); handleClick($('.menu-btn--pause'), () => setActiveMenu(MENU_MAIN)); // Score Menu handleClick($('.play-again-btn'), () => { setActiveMenu(null); resetGame(); }); handleClick($('.menu-btn--score'), () => setActiveMenu(MENU_MAIN)); // actions.js // ============================================================================ // ============================================================================ ////////////////// // MENU ACTIONS // ////////////////// function setActiveMenu(menu) { state.menus.active = menu; renderMenus(); } ///////////////// // HUD ACTIONS // ///////////////// function setScore(score) { state.game.score = score; renderScoreHud(); } function incrementScore(inc) { if (isInGame()) { state.game.score += inc; if (state.game.score < 0) { state.game.score = 0; } renderScoreHud(); } } function setCubeCount(count) { state.game.cubeCount = count; renderScoreHud(); } function incrementCubeCount(inc) { if (isInGame()) { state.game.cubeCount += inc; renderScoreHud(); } } ////////////////// // GAME ACTIONS // ////////////////// function setGameMode(mode) { state.game.mode = mode; } function resetGame() { resetAllTargets(); state.game.time = 0; resetAllCooldowns(); setScore(0); setCubeCount(0); spawnTime = getSpawnDelay(); } function pauseGame() { isInGame() && setActiveMenu(MENU_PAUSE); } function resumeGame() { isPaused() && setActiveMenu(null); } function endGame() { setActiveMenu(MENU_SCORE); handleCanvasPointerUp(); // Update high score if needed, AFTER rendering the score menu. if (state.game.score > getHighScore()) { setHighScore(state.game.score); } } //////////////////////// // KEYBOARD SHORTCUTS // //////////////////////// window.addEventListener('keydown', event => { if (event.key === 'p') { isPaused() ? resumeGame() : pauseGame(); } }); // tick.js // ============================================================================ // ============================================================================ let spawnTime = 0; const maxSpawnX = 450; const pointerDelta = { x: 0, y: 0 }; const pointerDeltaScaled = { x: 0, y: 0 }; // Temp slowmo state. Should be relocated once this stabilizes. const slowmoDuration = 1500; let slowmoRemaining = 0; let spawnExtra = 0; const spawnExtraDelay = 300; let targetSpeed = 1; function tick(width, height, simTime, simSpeed, lag) { PERF_START('frame'); PERF_START('tick'); state.game.time += simTime; if (slowmoRemaining > 0) { slowmoRemaining -= simTime; if (slowmoRemaining < 0) { slowmoRemaining = 0; } targetSpeed = pointerIsDown ? 0.075 : 0.3; } else { const menuPointerDown = isMenuVisible() && pointerIsDown; targetSpeed = menuPointerDown ? 0.025 : 1; } renderSlowmoStatus(slowmoRemaining / slowmoDuration); gameSpeed += (targetSpeed - gameSpeed) / 22 * lag; gameSpeed = clamp(gameSpeed, 0, 1); const centerX = width / 2; const centerY = height / 2; const simAirDrag = 1 - (airDrag * simSpeed); const simAirDragSpark = 1 - (airDragSpark * simSpeed); // Pointer Tracking // ------------------- // Compute speed and x/y deltas. // There is also a \"scaled\" variant taking game speed into account. This serves two purposes: // - Lag won't create large spikes in speed/deltas // - In slow mo, speed is increased proportionately to match \"reality\". Without this boost, // it feels like your actions are dampened in slow mo. const forceMultiplier = 1 / (simSpeed * 0.75 + 0.25); pointerDelta.x = 0; pointerDelta.y = 0; pointerDeltaScaled.x = 0; pointerDeltaScaled.y = 0; const lastPointer = touchPoints[touchPoints.length - 1]; if (pointerIsDown && lastPointer && !lastPointer.touchBreak) { pointerDelta.x = (pointerScene.x - lastPointer.x); pointerDelta.y = (pointerScene.y - lastPointer.y); pointerDeltaScaled.x = pointerDelta.x * forceMultiplier; pointerDeltaScaled.y = pointerDelta.y * forceMultiplier; } const pointerSpeed = Math.hypot(pointerDelta.x, pointerDelta.y); const pointerSpeedScaled = pointerSpeed * forceMultiplier; // Track points for later calculations, including drawing trail. touchPoints.forEach(p => p.life -= simTime); if (pointerIsDown) { touchPoints.push({ x: pointerScene.x, y: pointerScene.y, life: touchPointLife }); } while (touchPoints[0] && touchPoints[0].life = 0; i--) { const target = targets[i]; target.x += target.xD * simSpeed; target.y += target.yD * simSpeed; if (target.y < ceiling) { target.y = ceiling; target.yD = 0; } if (target.x < leftBound) { target.x = leftBound; target.xD *= -boundDamping; } else if (target.x > rightBound) { target.x = rightBound; target.xD *= -boundDamping; } if (target.z < backboardZ) { target.z = backboardZ; target.zD *= -boundDamping; } target.yD += gravity * simSpeed; target.rotateX += target.rotateXD * simSpeed; target.rotateY += target.rotateYD * simSpeed; target.rotateZ += target.rotateZD * simSpeed; target.transform(); target.project(); // Remove if offscreen if (target.projected.y > centerY + targetHitRadius * 2) { targets.splice(i, 1); returnTarget(target); if (isInGame()) { if (isCasualGame()) { incrementScore(-25); } else { endGame(); } } continue; } // If pointer is moving really fast, we want to hittest multiple points along the path. // We can't use scaled pointer speed to determine this, since we care about actual screen // distance covered. const hitTestCount = Math.ceil(pointerSpeed / targetRadius * 2); // Start loop at `1` and use ` { allVertices.push(...entity.vertices); allPolys.push(...entity.polys); allShadowVertices.push(...entity.shadowVertices); allShadowPolys.push(...entity.shadowPolys); }); // Scene calculations/transformations allPolys.forEach(p => computePolyNormal(p, 'normalWorld')); allPolys.forEach(computePolyDepth); allPolys.sort((a, b) => b.depth - a.depth); // Perspective projection allVertices.forEach(projectVertex); allPolys.forEach(p => computePolyNormal(p, 'normalCamera')); PERF_END('3D'); PERF_START('shadows'); // Rotate shadow vertices to light source perspective transformVertices( allShadowVertices, allShadowVertices, 0, 0, 0, TAU/8, 0, 0, 1, 1, 1 ); allShadowPolys.forEach(p => computePolyNormal(p, 'normalWorld')); const shadowDistanceMult = Math.hypot(1, 1); const shadowVerticesLength = allShadowVertices.length; for (let i=0; i { if (p.wireframe) { ctx.lineWidth = 2; ctx.beginPath(); const { vertices } = p; const vCount = vertices.length; const firstV = vertices[0]; ctx.moveTo(firstV.x, firstV.y); for (let i=1; i { event.isPrimary && handleCanvasPointerUp(); }); canvas.addEventListener('pointermove', event => { event.isPrimary && handleCanvasPointerMove(event.clientX, event.clientY); }); // We also need to know if the mouse leaves the page. For this game, it's best if that // cancels a swipe, so essentially acts as a \"mouseup\" event. document.body.addEventListener('mouseleave', handleCanvasPointerUp); } else { let activeTouchId = null; canvas.addEventListener('touchstart', event => { if (!pointerIsDown) { const touch = event.changedTouches[0]; activeTouchId = touch.identifier; handleCanvasPointerDown(touch.clientX, touch.clientY); } }); canvas.addEventListener('touchend', event => { for (let touch of event.changedTouches) { if (touch.identifier === activeTouchId) { handleCanvasPointerUp(); break; } } }); canvas.addEventListener('touchmove', event => { for (let touch of event.changedTouches) { if (touch.identifier === activeTouchId) { handleCanvasPointerMove(touch.clientX, touch.clientY); event.preventDefault(); break; } } }, { passive: false }); } // index.js // ============================================================================ // ============================================================================ setupCanvases();"}],"posts":[{"title":"Windows11系统初步设置与基础调试","slug":"Windows11系统初步设置与基础调试","date":"2024-09-05T06:05:52.000Z","updated":"2024-09-10T10:05:02.565Z","comments":true,"path":"2024/09/05/Windows11系统初步设置与基础调试/","permalink":"https://ly-chen04.github.io/2024/09/05/Windows11%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95/","excerpt":"从电脑选购到系统配置","text":"从电脑选购到系统配置 引入与准备阶段购买阶段 购入的渠道决定面临风险的程度，不要为了便宜去趟瑕疵重灾区的浑水。如果购买渠道为“建议”中的选项，可以跳过该部分，前往Windows11系统初步设置。建议：京东、天猫官网旗舰店、官方网站商城不建议：所有第三方店铺、拼多多、抖音直播间建议小白在购买之前和店铺客服确认产品配置与机器封装情况并保存聊天记录后再下单，有助于维护自身权益。官方的硬盘或内存定制机型99%是拆封过的，不建议购买，不如自己后期加装硬盘。要求卖家使用京东与顺丰快递（大不了就加钱），这两家的时效性很好也可以送货上门，不怎么会出现暴力运输的情况。大多笔记本外包装上的封条经过特殊设计，撕下会留有特定印记，封条有问题直接退货。不放心的也可以录制一个开箱视频，视频中要展示快递单号与包装全貌。 检验阶段 需要着重注意一下几点脚垫是否有灰尘或变形背盖螺丝是否有松动或拆卸痕迹机身及屏幕是否有指纹接口处是否有划痕及掉漆发现问题及时退货。 Windows11系统初步设置激活界面 电脑默认开启运输模式，首次开机需要接通电源。HP和机械革命是没有运输模式的。 到达联网界面后不要进行联网操作，联网会自动激活，失去7天无理由退换货资格。按下Shift+F10或者Shift+Fn+F10会弹出CMD窗口，输入以下代码回车，系统会自动重启 oobe\\BypassNRO.cmd 这时再进入联网界面就会多出现一个 我没有Internet连接 的选项，并在下一个菜单选择 继续执行受限操作 即可跳过。 隐私设置界面根据个人需要可以保留 位置 选项，其余选项都建议关闭。 Windows设置系统 按下 Win+i 可以快速打开Windows设置；因个体审美与需求差异，文本不会介绍Windows的个性化相关设置。 电源与电池 电源模式： 高性能 或 均衡 节电模式： 关闭 存储 按下 Win+E ，电脑中如果只有一个磁盘则跳过该部分。 高级存储设置→保存新内容的地方（将里面所有的项目均更改到 C:\\ 并逐个点击 应用 。） 就近共享 就近共享：关闭 开发者选项 开发人员模式：关闭 剪贴板 剪贴板历史记录：开启 跨设备的剪贴板历史记录：按需关闭 游戏GameBar 允许控制器打开GameBar：按需关闭 摄像 录制游戏过程：关闭 游戏模式 游戏模式：开启 辅助功能键盘 仅开启 使用“打印屏幕”键打开屏幕捕获 隐私和安全性常规 关闭所有选项 语音 在线语音识别：按需关闭 诊断和反馈 关闭所有选项 反馈频率：从不 活动历史记录 在此设备上存储我的活动历史记录：关闭 搜索权限 安全搜索：关闭 显示搜索焦点：关闭 搜索Windows 查找我的文件：增强 Windows更新 Windows的周期小更新以及补丁更新修复问题与带来新功能的同时可能出现新的bug，如果不介意此问题就跳过此部分。 暂停更新：暂停5周 安装显卡驱动程序 部分厂商会在出厂时为设备安装较新的显卡驱动程序，如果不确定或不放心也可以跟随以下指引。 Nvidia英伟达®显卡 Nvidia APP可以更方便地定期更新显卡驱动：点击跳转 仅下载驱动程序本体（手动驱动搜索）：点击跳转 AMD®显卡 统一安装与调试软件：点击跳转 安装完成后，重启电脑。 每个品牌的设备都会预装独立的性能控制软件，搭载独立显卡的机型需在软件内打开独显直连开关，在此就不过多赘述。 性能调优 此部分是为了使电脑在游戏时获得更好的性能释放而进行的操作。 Nvidia控制面板设置通过预览调整图像设置 预览：使用“高级3D图像”设置 管理3D设置 此处可以点击 程序设置 将想要更改的游戏程序添加进来，这样更改的设置只会影响所选程序。 在此页面上下浏览列表时建议使用右侧滑块控制。 单个页面更改完成后记得点击右下角 应用。 图形增强：关 CUDA-GPUs：全部 CUDA-系统内存回退政策：驱动器默认值（或者按需选择 偏好无系统内存回退） DSR-因数：OFF DSR-平滑度：关 OpenGL GDI 兼容性：自动 OpenGL 渲染GPU：自动选择 Vulkan&#x2F;OpenGL 现行方法：自动 三重缓冲：关 低延时模式：（按需选择），游戏内设置需要与此选项一致。 各向异性过滤：应用程序控制的 后台应用程序最大帧速率：关 垂直同步：使用3D应用程序设置 多帧采样 AA (MFAA)：关 平滑处理-FXAA：关 平滑处理-模式：应用程序控制的 平滑处理-灰度纠正：开 平滑处理-设置：应用程序控制的 平滑处理-透明度：关 最大帧速率：关 环境光吸收：关 电源管理模式：最高性能优先 着色器缓存大小：驱动程序默认值 纹理过滤-三线性优化：开 纹理过滤-各向异性采样优化：开 纹理过滤-负LOD偏移：允许 纹理过滤-质量：高性能 线程优化：（建议关闭） 虚拟现实-可变速率超级取样：关 虚拟现实预渲染帧数：1 首选刷新率：最高可用 配置Surround、PhysX PhysX设置→处理器：（选择以Nvidia开头的选项） 更改分辨率 应用以下分辨率→刷新率：（选择最大的数值） 应用以下设置：使用NVIDIA颜色设置 桌面颜色深度：（选择最大数值） 输出颜色深度：（选择最大数值） 输出颜色格式：（按需选择或者RGB） 输出动态范围：完全 调整桌面尺寸与位置 缩放→选择缩放模式：（按需设置或者全屏） 对以下项目执行缩放：GPU 覆盖由游戏和程序设置的缩放模式：✓ 调整视频颜色设置 您如何进行颜色调整：通过NVIDIA设置 高级→动态范围：完全 调整视频图像设置 RTX视频增强：按需开启，质量：自动 AMD显卡设置 敬请期待。","categories":[],"tags":[{"name":"赛博说明书","slug":"赛博说明书","permalink":"https://ly-chen04.github.io/tags/%E8%B5%9B%E5%8D%9A%E8%AF%B4%E6%98%8E%E4%B9%A6/"}]},{"title":"EULA与隐私政策","slug":"EULA与隐私政策","date":"2024-09-05T06:04:50.000Z","updated":"2024-09-06T15:59:58.248Z","comments":true,"path":"2024/09/05/EULA与隐私政策/","permalink":"https://ly-chen04.github.io/2024/09/05/EULA%E4%B8%8E%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/","excerpt":"更新日期：2024&#x2F;9&#x2F;5生效日期：2024&#x2F;9&#x2F;5","text":"更新日期：2024&#x2F;9&#x2F;5生效日期：2024&#x2F;9&#x2F;5 EULA（最终用户协议）隐私政策最终用户许可协议（EULA） 重要提示： 本最终用户许可协议（以下简称“本协议”）是您（个人、公司或其他任何实体）与 OYAMAMahiro 网站（以下简称“网站”）之间就使用网站及其相关服务所订立的法律协议。使用本网站前，请您仔细阅读本协议。使用本网站即表示您同意接受本协议的所有条款。如果您不同意本协议，请勿使用本网站。 1. 一般规定 （一） 本协议中的“服务”包括： 网站内容：包括但不限于存储在网站上的文章、图片、视频以及其他信息； 评论系统：允许用户在网站上发布评论和反馈； 网站功能：包括但不限于文章浏览、评论功能、搜索功能等。 （二） 本网站可能会使用第三方服务（如广告、分析工具等），这些第三方服务可能会有自己的使用条款和隐私政策。 2. 使用许可 （一） 在遵守本协议条款的情况下，您被授予在个人计算机或移动设备上以非商业目的访问和使用本网站的权限。您不得将本网站用于商业用途，包括但不限于销售、租赁或转让本网站的访问权限。 （二） 您同意不使用本网站从事以下行为： 未经授权的复制或分发：不允许未经授权的复制、转载、分发或以其他方式使用本网站的内容。 破坏性行为：不允许通过任何手段干扰、破坏或损害本网站的正常运作。 非法活动：不允许使用本网站从事任何非法活动，包括但不限于发布虚假信息、侵犯他人隐私或版权的行为。 3. 评论系统 （一） 您可以在本网站上发布评论。请遵守以下规则： 真实准确：评论内容应真实准确，不得发布虚假或误导性的信息。 尊重他人：不得发布任何辱骂、侮辱或其他不当言论。 法律合规：评论内容不得违反任何适用法律法规。 （二） 本网站保留审查和删除不符合规定的评论的权利。 4. 隐私政策 （一） 隐私政策：我们致力于保护您的隐私。我们将依据隐私政策收集、使用和保护您的个人信息。请访问我们网站上的隐私政策页面了解详细信息。 （二） 信息收集：网站可能会收集必要的用户信息，如 IP 地址、浏览器类型、访问时间等。这些信息仅用于改进网站服务和用户体验。 （三） 信息安全：我们将采取适当的技术和组织措施保护您的个人信息，但不能保证所有数据传输过程中的绝对安全。 5. 软件更新 本网站不涉及软件更新相关条款。 6. 服务条款 （一） 本网站提供的信息和服务仅供参考，不保证其准确性、完整性和时效性。 （二） 服务变更：我们保留随时修改、更新或终止服务的权利，无需事先通知。 7. 第三方服务 （一） 本网站可能包含第三方链接或服务。对于这些第三方链接或服务的内容和操作，我们不承担任何责任。 （二） 第三方服务：使用第三方服务时，您需遵守相关的条款和隐私政策。 8. 免责声明 （一） 本网站及其所有内容按“原样”提供，不提供任何明示或暗示的担保，包括但不限于适销性、适合特定用途和不侵权的担保。 （二） 责任限制：对于因使用或无法使用本网站而引起的任何损失或损害（包括但不限于数据丢失、业务中断等），我们不承担任何责任。 9. 终止和持续有效性 （一） 终止：如果您违反本协议的任何条款，我们有权随时终止您的使用权限。终止后，您应立即停止使用本网站。 （二） 持续有效性：本协议中的条款在协议终止后仍将继续有效。 10. 争议解决和适用法律 （一） 本协议受中华人民共和国法律管辖。 （二） 任何因本协议引起的争议应通过友好协商解决，协商不成时，任何一方均可向协议签署地有管辖权的法院提起诉讼。 11. 完整协议 （一） 本协议构成您与网站之间就使用本网站达成的完整协议，取代之前的任何口头或书面协议。 （二） 当使用第三方内容或服务时，您可能还需要遵守其他适用的条款和条件。 上次更新时间：2024年9月 版权所有 © OYAMAMahiro 2024 保留所有权利。 请根据你的实际需求对上述文本进一步修改和调整。如果有其他具体要求或内容需要添加，请告知我！ OYAMAMahiro网站 是一款由 L.Y. Chen （以下简称“我们”）提供的产品。您在使用我们的服务时，我们可能会收集和使用您的相关信息。我们希望通过本《隐私政策》向您说明，在使用我们的服务时，我们如何收集、使用、储存和分享这些信息，以及我们为您提供的访问、更新、控制和保护这些信息的方式。本《隐私政策》与您所使用的 OYAMAMahiro网站 服务息息相关，希望您仔细阅读，在需要时，按照本《隐私政策》的指引，作出您认为适当的选择。本《隐私政策》中涉及的相关技术词汇，我们尽量以简明扼要的表述，并提供进一步说明的链接，以便您的理解。 您使用或继续使用我们的服务，即意味着同意我们按照本《隐私政策》收集、使用、储存和分享您的相关信息。 如对本《隐私政策》或相关事宜有任何问题，请通过 &#67;&#x37;&#51;&#x35;&#53;&#x36;&#48;&#x38;&#x40;&#102;&#x6f;&#120;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d; 与我们联系。 1. 我们收集的信息我们或我们的第三方合作伙伴提供服务时，可能会收集、储存和使用下列与您有关的信息。如果您不提供相关信息，可能无法注册成为我们的用户或无法享受我们提供的某些服务，或者无法达到相关服务拟达到的效果。 位置信息，指您开启设备定位功能并使用我们基于位置提供的相关服务时，收集的有关您位置的信息，包括： 您通过具有定位功能的移动设备使用我们的服务时，通过GPS或WiFi等方式收集的您的地理位置信息； 您可以通过关闭定位功能，停止对您的地理位置信息的收集。 日志信息，指您使用我们的服务时，系统可能通过cookies、标识符及相关技术收集的信息，包括您的设备信息、浏览信息、点击信息，并将该等信息储存为日志信息，为您提供个性化的用户体验、保障服务安全。您可以通过浏览器设置拒绝或管理cookie、标识符或相关技术的使用。 我们接入的第三方SDK： Google分析服务 第三方名称：Google.LLC 使用目的：网站维护与内容质量升级 收集个人信息类型：用户IP地址和用户会话动作 处理方式：匿名化处理 隐私政策链接：Google隐私政策 2. 信息的存储2.1 信息存储的方式和期限 我们会通过安全的方式存储您的信息，包括本地存储（例如利用APP进行数据缓存）、数据库和服务器日志。 一般情况下，我们只会在为实现服务目的所必需的时间内或法律法规规定的条件下存储您的个人信息。 2.2 信息存储的地域 我们会按照法律法规规定，将境内收集的用户个人信息存储于中国境内。 目前我们不会跨境传输或存储您的个人信息。将来如需跨境传输或存储的，我们会向您告知信息出境的目的、接收方、安全保证措施和安全风险，并征得您的同意。 2.3 产品或服务停止运营时的通知 当我们的产品或服务发生停止运营的情况时，我们将以推送通知、公告等形式通知您，并在合理期限内删除您的个人信息或进行匿名化处理，法律法规另有规定的除外。 3. 信息安全我们使用各种安全技术和程序，以防信息的丢失、不当使用、未经授权阅览或披露。例如，在某些服务中，我们将利用加密技术（例如SSL）来保护您提供的个人信息。但请您理解，由于技术的限制以及可能存在的各种恶意手段，在互联网行业，即便竭尽所能加强安全措施，也不可能始终保证信息百分之百的安全。您需要了解，您接入我们的服务所用的系统和通讯网络，有可能因我们可控范围外的因素而出现问题。 4. 我们如何使用信息我们可能将在向您提供服务的过程之中所收集的信息用作下列用途： 向您提供服务； 在我们提供服务时，用于身份验证、客户服务、安全防范、诈骗监测、存档和备份用途，确保我们向您提供的产品和服务的安全性； 帮助我们设计新服务，改善我们现有服务； 使我们更加了解您如何接入和使用我们的服务，从而针对性地回应您的个性化需求，例如语言设定、位置设定、个性化的帮助服务和指示，或对您和其他用户作出其他方面的回应； 向您提供与您更加相关的广告以替代普遍投放的广告； 评估我们服务中的广告和其他促销及推广活动的效果，并加以改善； 软件认证或管理软件升级； 让您参与有关我们产品和服务的调查。 5. 信息共享目前，我们不会主动共享或转让您的个人信息至第三方，如存在其他共享或转让您的个人信息或您需要我们将您的个人信息共享或转让至第三方情形时，我们会直接或确认第三方征得您对上述行为的明示同意。 为了投放广告，评估、优化广告投放效果等目的，我们需要向广告主及其代理商等第三方合作伙伴共享您的部分数据，要求其严格遵守我们关于数据隐私保护的措施与要求，包括但不限于根据数据保护协议、承诺书及相关数据处理政策进行处理，避免识别出个人身份，保障隐私安全。 我们不会向合作伙伴分享可用于识别您个人身份的信息（例如您的姓名或电子邮件地址），除非您明确授权。 我们不会对外公开披露所收集的个人信息，如必须公开披露时，我们会向您告知此次公开披露的目的、披露信息的类型及可能涉及的敏感信息，并征得您的明示同意。 随着我们业务的持续发展，我们有可能进行合并、收购、资产转让等交易，我们将告知您相关情形，按照法律法规及不低于本《隐私政策》所要求的标准继续保护或要求新的控制者继续保护您的个人信息。 另外，根据相关法律法规及国家标准，以下情形中，我们可能会共享、转让、公开披露个人信息无需事先征得您的授权同意： 与国家安全、国防安全直接相关的； 与公共安全、公共卫生、重大公共利益直接相关的； 犯罪侦查、起诉、审判和判决执行等直接相关的； 出于维护个人信息主体或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 个人信息主体自行向社会公众公开个人信息的； 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道。 6. 您的权利在您使用我们的服务期间，我们可能会视产品具体情况为您提供相应的操作设置，以便您可以查询、删除、更正或撤回您的相关个人信息，您可参考相应的具体指引进行操作。此外，我们还设置了投诉举报渠道，您的意见将会得到及时的处理。如果您无法通过上述途径和方式行使您的个人信息主体权利，您可以通过本《隐私政策》中提供的联系方式提出您的请求，我们会按照法律法规的规定予以反馈。 7. 变更我们可能适时修订本《隐私政策》的条款。当变更发生时，我们会在版本更新时向您提示新的《隐私政策》，并向您说明生效日期。请您仔细阅读变更后的《隐私政策》内容，若您继续使用我们的服务，即表示您同意我们按照更新后的《隐私政策》处理您的个人信息。 8. 未成年人保护我们鼓励父母或监护人指导未满十八岁的未成年人使用我们的服务。我们建议未成年人鼓励他们的父母或监护人阅读本《隐私政策》，并建议未成年人在提交的个人信息之前寻求父母或监护人的同意和指导。","categories":[],"tags":[{"name":"网站信息公示","slug":"网站信息公示","permalink":"https://ly-chen04.github.io/tags/%E7%BD%91%E7%AB%99%E4%BF%A1%E6%81%AF%E5%85%AC%E7%A4%BA/"}]},{"title":"完美世界电竞上海Major 2024","slug":"CS2","date":"2024-08-22T12:09:44.000Z","updated":"2024-09-05T06:39:44.192Z","comments":true,"path":"2024/08/22/CS2/","permalink":"https://ly-chen04.github.io/2024/08/22/CS2/","excerpt":"","text":"","categories":[],"tags":[{"name":"CS","slug":"CS","permalink":"https://ly-chen04.github.io/tags/CS/"}]},{"title":"OBS_推流录制工具","slug":"OBS-推流录制工具","date":"2024-06-16T04:05:07.608Z","updated":"2024-09-10T10:15:33.755Z","comments":true,"path":"2024/06/16/OBS-推流录制工具/","permalink":"https://ly-chen04.github.io/2024/06/16/OBS-%E6%8E%A8%E6%B5%81%E5%BD%95%E5%88%B6%E5%B7%A5%E5%85%B7/","excerpt":"基于OBS 28.0 的基础面板解释。","text":"基于OBS 28.0 的基础面板解释。 OBS——推流录制工具OBS (Open Broadcaster Software) 是一款开源、免费、跨平台的直播推流和视频录制工具，它功能强大、可调空间大、上限很高，但是因为它主要为直播而设计，录制操作的便利性较差，上手有一定难度。和一众录屏工具（包括N&#x2F;A卡驱动自带录屏）和它的套皮软件相比，OBS 属于那种 “愿意花一些时间研究能带来更高画质和效率” 的工具。 本文将会基于 28.0 版本介绍直播推流和录制相关的设置，并以CSGO素材录制为例介绍游戏场景下的设置策略和一些 Trick，注意 OBS 实际分为 Studio 和 Classic 两个版本，Classic 版本有更好的兼容性，对较老的系统和设备有些用处，一般都用 Studio 版本。 安装官网：https://obsproject.com 项目：https://github.com/obsproject/obs-studio 论坛：https://obsproject.com/forum 资源：https://obsproject.com/forum/resources 资源页包含各种插件、脚本、主题和工具。 OBS Studio 已经登录 Steam 商店，同样免费。如果担心下载和更新的速度，可以直接从 Steam 下载，相对更加方便。 初识OBS启动 OBS，忽略首次引导，主界面如图所示。可以看到界面分为以下几个部分： 顶部菜单栏 预览窗口 快捷工具栏 来源 混音器 场景 转场特效 控件 来源面板看到 来源 面板，我们需要添加合适的源得到想要的画面，这里的源类似 PhotoShop 里 图层 的概念，上层会覆盖下层，顺序可以随意调整，来源不可用时为透明，不会影响下一层。 可以添加的来源有很多种，首先添加一个 显示器采集 源，一切默认，这样我们就能预览看到画面了。 游戏源 和 窗口采集 可以专门捕获全屏游戏或某个游戏&#x2F;窗口，捕获游戏时的性能会更好，可以把它们放在显示器源的上层，兼顾性能和便利，也可以关闭显示器源，不暴露桌面情况只展示特定游戏或窗口。 应用程序音频捕获 是当前正在测试的功能，可以获取特定程序的声音，特别适合分离游戏&#x2F;语音音源，方便后期处理，后面会详细介绍。 混音器面板这里我们可以调整各个声音来源的音量和滤镜，改变它们的混合比例。打开某个音源的滤镜页，可以添加 降噪、阈值 等滤镜，包括电脑中已安装的VST效果，图中简单加了一个 噪音抑制，效果尚可。 点“齿轮”按钮或右键打开高级音频属性，这里可以进一步调整音量、左右平衡、偏移和监听，和较为重要的轨道。轨道中某个数字是否勾选代表它是否在该轨道中出现，一般会在轨道1中保留主要声音&#x2F;直播观众听到的声音，其他轨道分别设置麦克风、开黑语音等音源，方便后期处理。 场景面板设置和调整各个场景（Scene），直播往往需要多个不同场景，如正式开播前的等候场景、游戏A、B、C的场景、聊天场景等等。提前设置好各个场景可以避免来源面板臃肿和不断开关来源的麻烦。搭配相应的工具（如StreamDeck）可以实现快速切换场景，给直播带来便利。 场景之上还有一个场景集合的概念，在顶部菜单栏可以看到，可以更方便的分组、导入导出场景设置。 转场特效面板调整场景切换时的转场特效，默认只有渐变和裁切，即交叉溶解和硬切，通过安装转场插件可以添加更多效果。 预览窗口除了实时预览效果，在预览窗口还可以全屏投影、截屏和调整源的尺寸及位置。 配置文件类似刚才提到的场景集合，每一个配置文件对应一组接下来要介绍的设置，整个设置面板的内容都包括在内（录制、推流、快捷键等），注意它和场景互不干扰，要分别设置。 设置从控件面板点击按钮打开设置面板，这里按照录制设置的逻辑顺序介绍，以下每一小节对应左侧的标签栏名称。 视频在这里可以调整画布和输出的分辨率、缩小方法和录制帧率FPS。 两个分辨率一般保持一致，即你想要的录制&#x2F;推流分辨率，并且此时缩小方法不会生效。基础分辨率大于输出分辨率相当于超采，理论上画面细节会更好，性能消耗也会更高。不过这里调整缩放和来源设置的缩放有些重复，除非想要1080P推流同时4K录像，一般不要动，一致即可。 常用 FPS 值 不超过60，想要录制更高帧率可以改成 整数 FPS 值，最高能到120，再往上可以设置分数 FPS 值，如 180FPS -&gt; 180/1，不过此时录制的性能一般有瓶颈。 高级高级页一般要注意的是 视频、录像、串流延迟这三个部分。 色彩格式默认的NV12适合推流，设置成其他格式则会有格式转换的性能消耗，但如果机器的性能尚可，建议设置成 I420。如果追求更高的画质，I420下色彩信息损失较多，可以考虑修改为 I444，但它的兼容性较差，请务必确认你所使用的软件能够正确识别和播放。 想要进一步了解可以搜索 色度抽样 色彩范围设置为有限会丢弃掉一些超黑超白数据。直播场景建议保持 受限 以规避一些问题。在录制场景下可以设置为 完全，注意此时部分播放器可能会出现异常。 录像的文件名格式中包含年月日和时间，可以根据需要修改。 自动封装至MP4格式再录制文件格式为MKV时会自动在录制完成后转换格式，后文中展开说明。 回放缓存文件名前缀&#x2F;后缀 设置回放缓存（即时重放）功能保存的视频文件名，和录制得到的文件作区分，建议前缀或者后缀改成即时重放。 串流延迟顾名思义，主要用于游戏直播防窥屏等需求。 输出输出页包含推流、录像、音频和回放缓存（即时重放）的设置，也是OBS设置的难点。 输出模式建议设置成 高级 以获得最大的调整空间，简单模式 下的录像设置不是很够。如果你想要更简单一些，可以先看下去，如果你需要的选项在 简单模式 下就能调整好也可以不动。 编码器编码器是OBS设置的重点。其中 x264 是 CPU 软件编码，比较吃CPU的性能和多核性能，而显卡编码一般对性能影响较小，但是画质较差，NVIDIA显卡有 NVENC，AMD显卡有 AMF，Intel显卡有 QuickSync，Mac下也有对应的编码器。 显卡编码非常适合游戏场景，我们可以把推流和录像都设置成显卡编码或者一个CPU编码、一个显卡编码平衡负载。 x264 编码器一般关注这三个设置 码率控制：固定码率CBR&#x2F;可变码率VBR&#x2F;CRF VBR 更节省码率，但画面变换时码率变换可能滞后导致码率不够，出现明显模糊 CRF 模式适合录像，数值越低画质越高 比特率：CBR&#x2F;VBR下可用 直播建议在 4000Kbps 以上 8000Kbps 附近比较适合 1080P 直播 码率上限取决于网络的上行带宽，建议测试网速确保带宽足够 CPU使用预设：对CPU占用影响较大，掉帧时提高（使用更快）预设 NVIDIA NVENC H.264 编码器 可以尝试使用 NVIDIA NVENC HEVC，但要考虑到直播平台是否支持，和部分设备无法硬解时出现的卡顿情况。 速率控制：同上码率控制 最大比特率：可以在比特率的基础上加 2000~5000 Kbps 预设：直播时尽可能在带有性能的三个档位中选择，推荐 性能 录像：CQP 模式，数值 12~23；预设改为质量/最高质量 Apple ProRes 编码器安装 StreamFX 插件后可用，录像时可以考虑尝试使用，适用于对画质要求高且配置、存储足够的用户，建议配置设置 422标准 或 422高品质 更多的编码知识和OBS编码器设置作业参见 iAvoe的文档 录像录像格式：即录像文件的封装格式，OBS 里的编码格式基本都支持 mp4&#x2F;mov&#x2F;mkv 封装，区别是 mkv 封装遇到断电等意外情况时可以保留之前录好的部分，菜单栏-文件-录像转封装 处转换为 mp4 格式后即可正常播放，但是部分播放器和软件（如旧版本Pr&#x2F;Ae）支持较差，可能会无法播放。有需要可以前往 高级页 设置自动转换封装。 音轨：如要分离音频方便后期处理，这里务必勾选上所有要用到的音轨。 编码器：如设置成 （使用推流编码器），则会把直播的画面直接保存到本地，但对录像来说画质可能不够好，只求记录时可以这样设置，追求画面则设置成其他编码器。 重新缩放输出：期望的推流和录像分辨率不一致时启用。 自动分割文件：录制时间较长时可以固定文件大小&#x2F;时长分割保存到硬盘中，降低意外情况下的风险，也方便筛选素材。 音频这里可以设置更高的比特率&#x2F;码率&#x2F;位率，提高声音质量，也可以给不同的轨道起名字方便后期区分。 回放缓存相当于N卡的即时重放，非常适合保存游戏的高光时刻。 最长回放时间：建议设置 90s 或 120s 强迫症玩家可以 +1s 不然实际时长会小 1s 最大内存：无法估计时尽可能给高，如 4096MB 或 8192MB 推流这里设置推流的服务器和秘钥，OBS默认并不支持国内的直播平台，把服务修改成 自定义...，从直播平台的开播页找到服务器地址和秘钥并复制到这里，注意不要泄露秘钥。 快捷键这里没有什么难点，注意开始推流&#x2F;停止推流设置同一个快捷键时，按键为开关式，一开一关。一般建议设置的快捷键： 开始推流 停止推流 开始录制 停止录制 开始回放缓存 停止回放缓存 保存回放（输出页启用回放缓存后才可见） CSGO素材录制画面捕获 想得到拉伸画面，对源右键-变换-拉伸到全屏 或者选中源 Ctrl+S 取消相应游戏源&#x2F;窗口捕获&#x2F;显示器捕获中的 显示鼠标指针 受CSGO受信任模式的影响，官方匹配&#x2F;直接启动游戏时无法捕获游戏流，只能捕获显示器，性能较差；平台游戏不受影响。 针对本地回放录像 demo 录屏有两种解决方法： 启动项添加 -allow_third_party_software 使用 HLAE 启动 CSGO 声音捕获 在来源面板添加应用程序音频捕获，先启动一次游戏并设置好捕获的窗口 csgo.exe。 在高级音频属性中调整轨道分配，让游戏的音频单独一轨，设置-音轨-录像启用对应轨道。 录像设置CPU&#x2F;显卡编码根据个人偏好和电脑配置情况选择，以下给出推荐设置： x264 编码器 码率控制模式：强烈建议选择 CRF CRF 的数值越小，画质越高，文件越大，推荐范围 6~16 CRF 数值减 6，码率翻倍 CPU 使用预设 veryfast ~ ultrafast 选一个当前设置下不掉帧的档位，建议 ultrafast NVIDIA NVENC H.264&#x2F;HEVC 编码器 编码器：HEVC 比 H.264 效率更高，尤其是高分辨率 速率控制：由于没有 CRF 模式，这里选择 CQP 模式 CQ 级别： H.264：推荐 12，不超过 23 HEVC：推荐 16，不超过 26 预设：选 质量 或 最高质量 Apple ProRes 编码器配置选择 422 标准（APCN） 游戏设置 窗口模式 取消绑定 Ctrl，追踪投掷物从 Alt 改为 R，避免切屏和截图时出现异常 游戏中播放和暂停快捷键可与 OBS 开始&#x2F;结束录制保持一致 控制台指令 engine_no_focus_sleep 0 确保窗口失焦后不掉帧 慢放录像，如 1&#x2F;4：demo_timescale 0.25 或 Shift+F2 在 demoui 中手动操作 限制游戏渲染帧率，如 120fps：fps_max 120 帧率调整录制高帧率素材的时候我们一般会慢放录像+限制FPS节省资源给OBS留出更多的性能空间，在编码设置确定之后调整录制帧率可以明显提高录制的速度，可参照上文设置120FPS甚至更高的帧率。 菜单栏-停靠窗口-统计：启用统计面板，可以看到由于渲染延迟错过的帧和由于编码延迟跳过的帧和FPS。颜色变黄&#x2F;变红或丢帧较多时（偶尔）说明当前设置无法完美录像，需要调整编码器设置或降低录制FPS。","categories":[],"tags":[{"name":"赛博说明书","slug":"赛博说明书","permalink":"https://ly-chen04.github.io/tags/%E8%B5%9B%E5%8D%9A%E8%AF%B4%E6%98%8E%E4%B9%A6/"}]},{"title":"Intel QSV在FFmpeg中的实现与使用","slug":"Intel QSV在FFmpeg中的实现与使用","date":"2024-06-16T04:05:07.600Z","updated":"2024-09-10T10:20:19.666Z","comments":true,"path":"2024/06/16/Intel QSV在FFmpeg中的实现与使用/","permalink":"https://ly-chen04.github.io/2024/06/16/Intel%20QSV%E5%9C%A8FFmpeg%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"文章摘自CSDN社区。本文经修改。","text":"文章摘自CSDN社区。本文经修改。 一、处理器整体架构英特尔的图形处理GPU被称为“核芯显卡”，与CPU集成封装在同一个芯片上，上图展示的是芯片的内部结构。 1.1 发展英特尔从lvy Bridge架构开始就尝试将GPU与CPU集成在中央处理芯片中并逐代发展到Skylake架构。初期的Ivy Bridge架构中GPU所占的面积非常小，而到现在的第五代处理器架构Skylake已经实现十分成熟的GPU集成技术，GPU在芯片中所占的面积已经超过了一半。在未来将推出基于PCI-E的独立显卡，为PC带来更大的图像性能提升。 1.2 基础功能模块上图展示的是一款GPU所具备的一些基础功能模块。英特尔的核芯显卡分为普通的Intel HD Graphics与性能强大的Intel Iris (Pro)Graphics，其中硬件结构的变化决定性能的高低。GPU中的Slice个数越多，处理单元的组织方式越多，性能便越强大。 Intel HD Graphics也就是GT2中只有一个Slice，而对于Iris系列中的GT3则有两个Slice；GT3e相对于GT3增加了eDRAM使其具有更快的内存访问速度，而GT4e则增加到三个Slice。 GPU的基础功能模块主要由EU以及相关的Media Processing（MFX）等组成。一个Slice中有三个Sub-Slice，Sub-Slice中包含具体的EU和Media Sampler模块作为最基本的可编程处理单元，GPU相关的任务都是在EU上进行。而Media Processing中还集成了一个被称为MFX的独立模块，主要由Media Format Codec（MFX）与VQE组成。 MFX可将一些处理任务通过Fix Function打包，固定于一个执行单元中进行统一的编解码处理，不调用EU从而实现提高EU处理3D图形等任务的速度。Video Quality Engine（VQE）提供De-interlace与De-Noise等视频处理任务，在编解码中使用EU是为了得到更高的视频编码质量。 1.3 结构演进上图展示的是英特尔几代核芯显卡产品在结构上的变化。 最早的Haswell架构也就是v3系列中的EU个数相对较少，最多为40个；而到Broadwell架构的GT3中集成了2个Slice，EU个数随之增加到48个，图像处理性能也随之增强。 从Broadwell架构发展到Skylake架构，除了EU与Slice格式增加的变化，MFX的组织也有相应改进。Broadwell架构是将MFX集成于一个Slice中，一个Slice集成一个MFX；而到Skylake架构之后Slice的个数增加了但MFX的个数并没有，此时的MFC便集成在Slice之外。 随着组织方式的改变，核芯显卡的功能也随之改变：Skylake增加了HEVC的Decoder、PAK增加了基于HEVC的处理功能等改进为核芯显卡整体处理性能带来了显著提升，第六代以后的核芯显卡也都主要沿用GT3的架构组织。 从Driver分发下来的Command Stream回通过多条路径在GPU上得到执行：如果命令属于编解码的Fix Function则会由MFX执行，部分与视频处理相关的命令会由VQE执行，其他的命令则会由EU执行。 而编码过程主要分为两部分：ENC与PAK。ENC主要通过硬件实现Rate Control、Motion Estimation、Intra Prediction、Mode Decision等功能；PAK进行Motion Comp、Intra Prediction、Forward Quant、Pixel Reconstruction、Entropy Coding等功能。在目前的英特尔架构中，Media SDK通过API对硬件进行统一的调度与使用，同时我们提供更底层的接口Flexible Encoder Interface（FEI）以实现更优秀的底层调度与更好的处理效果。 2、软件策略最底层的FFmpeg可允许开发者将QSV集成进FFmpeg中以便于开发，而Media SDK则主要被用于编解码处理，FFmpeg可把整个多媒体处理有效结合。 如果开发者认为传统的Media SDK的处理质量无法达到要求或码率控制不符合某些特定场景，那么可以通过调用FEI等更底层的接口对控制算法进行优化；最顶层的OpenCL接口则利用GPU功能实现边缘计算等处理任务，常见的Hybrid编码方式便使用了OpenCL。除此之外OpenCL也可实现一些其他的并行处理功能，例如与AI相关的一些计算。 2.1 Media SDKMedia SDK分为以下几个版本：Community Edition是一个包含了基本功能的部分免费版本，Essential Edition与Professional Edition则是具有更多功能的收费版本，可实现例如hybrid HEVC 编码，Audio的编解码、Video Quality Caliper Tool等诸多高级功能和分析工具的集合。 软件架构 上图主要介绍的是Media Server Studio Software Stack软件架构，我们基于此架构实现FFmpeg的加速。 这里需注意： OpenGL （mesa）与linux内核一直是开源的项目，但之前版本的MSS中存在一些私有的内核补丁，并对操作系统的或对Linux的内核版本有特殊要求。 HD Graphics Driver for Linux之前是一个闭源的方案，而现在的MSDK 和用户态驱动（iHD驱动）都已经实现开源。现在我们正在制作一个基于开源版本的Release，未来大家可以通过此开源平台获得更好的技术支持。 编解码支持 关于编解码支持，其中我想强调的是HEVC 8 bit 与10 bit的编解码。在Gen 9也就是Skylake上并不支持硬件级别的HEVC 10 bit解码，面对这种情况我们可以通过混合模式实现对HEVC 10 bit的编解码功能。最新E3v6（Kabylake）虽然只有较低性能的GPU配置，但可以支持HEVC 10 bit解码，HEVC 10 bit编码功能则会在以后发布的芯片中提供。 2.2 QSV到FFmpeg的集成思路 FFmpeg集成的思路主要如下： FFmpeg QSV Plugins：将SDK作为FFmpeg的一部分进行封装，其中包括Decoder、Encoder与VPP Filter处理。 VAPPI Plugin：Media对整个英特尔GPU的软件架构而言，从最底层的linux内核，中间有用户态驱动，对外的统一的接口就是VAAPI。Media SDK的硬件加速就是基于VAAPI开发，同时增加了很多相关的功能，其代码更为复杂；而现在增加的VAAPI Plugin则会直接调用LibAV使软硬件结合更为紧密。 将SDK集成到FFmpeg中，一共分为AVDecoder、AVEncoder、AVFilter三个部分： AVFilter AVFilter主要是利用硬件的GPU实现Video Processor功能，其中包括vpp_qsv、overlay_qsv、hwupload_qsv，其中我们重点开发了overlay_qsv，vpp_qsv与hwupload_qsv。 如果在一个视频处理的pipeline中有多个VPP的实例运行，会对性能造成很大的影响。我们的方案是实现一个大的VPP Filter中集成所有功能并通过设置参数实现调用，避免了多个VPP的实例存在。 但是为什么将vpp_qsv与overlay_qsv分开？这是因为无法在一个VPP实例中同时完成compositor和一些视频处理功能（像de-interlace等）。英特尔核芯显卡内显存中的存储格式为NV12， 和非硬件加速的模块联合工作时，需要对Frame Buffer进行从系统内存到显卡显存的复制过程，hwupload_qsv提供了在系统内存和显卡内存之间进行快速帧转换的功能。 AVEncoder AVEncoder目前支持H264、HEVC、MPEG-2等解码的硬件加速。 AVDecoder AVDecoder目前支持H264、HEVC、MPEG-2等协议的硬件加速。 最理想的方案是在整条视频处理的Pipeline中都使用显卡内存从而不存在内存之间的帧拷贝，从而达到最快的处理速度，但在实际应用中我们很多时候是做不到这一点。 将MSDK集成进FFmpeg中时需要解决内存转换的问题，例如VPP Filter不支持一些功能或原始码流并不在Decoder支持的列表中。上图中粉色与绿色的转换表示的就是数据从显存到系统内存再到显存之间的转换。我们在实践中经常会遇到处理性能的急剧变化，可能的原因就是一些非硬件处理的模块和硬件加速的模块存在与同一个pipeline中，从而对整体性能造成影响。这是因为进行了额外的内存拷贝过程，一旦优化不足则会极大影响性能。 具体进行内存分配时我们使用了hwcontext，这是FFmpeg在3.0之后增加的一个功能。我们基于FFmpeg中hwcontext的机制实现了hwcontext_qsv，从而对硬件的初始化与内存分配进行很好的管理。 三、对比MSS与FFmpeg+QSV 二者支持相同的编解码器与视频处理。 二者的差异有： MSS 仅提供了一套库和工具，用户必须基于 MSS进行二次开发；而FFmpeg 是一个流行的多媒体开放框架, QSV的GPU加速只是其中的一部分。 MSS的库中提供 了VPP 接口，用户要实现某些功能必须进行二次开发。而目前,FFmpeg+QSV已存在2个开发好的Filter，并且在Filter中集成了MSS 支持的所有功能，并提供更加简单的选项进行配置，这些功能对用户而言都是方便使用的。 在内存管理上，MSS的开发人员必须管理自己的内存；而FFmpeg 提供基本的内存管理单元并实现系统内存的统一调用，集成了硬件级别的内存处理机制。 FFmpeg 提供了一定的容错机制与 a&#x2F;v 同步机制；FFmpeg+QSV 模块充分利用这些机制来提高兼容性，像使用ffmpeg的parse工具进行视频流预处理。 处理流程上，MSS的用户在使用MSS模块之前必须自己开发Mux&#x2F;Demux或其他必要的模块；而FFmpeg+QSV 由于是基于 MSS 实现并添加了特殊的逻辑, 每个模块都可与 FFmpeg 的其他模块一起工作。 可以说FFmpeg有很强大的媒体支持，相对于传统的MSS在保证性能与质量的前提下为用户节省很多工作量并显著提升开发效率。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://ly-chen04.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"CS2控制台指令简明索引","slug":"CSGO控制台指令简明索引","date":"2023-11-08T23:05:08.000Z","updated":"2024-09-05T07:07:56.467Z","comments":true,"path":"2023/11/09/CSGO控制台指令简明索引/","permalink":"https://ly-chen04.github.io/2023/11/09/CSGO%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%8C%87%E4%BB%A4%E7%AE%80%E6%98%8E%E7%B4%A2%E5%BC%95/","excerpt":"注：随Valve推送游戏进度本文部分内容或将不适用更新版本。","text":"注：随Valve推送游戏进度本文部分内容或将不适用更新版本。 V社(Valve)的Source起源引擎制作的游戏都可以开发者控制台，简称控制台console，使用控制台可以实现很多游戏的设置面板无法提供的功能，比如跳投、切换准星参数、颜色等等特殊功能都是利用了控制台的指令实现的，这也是CS游戏的一大特色了。 开启控制台在游戏的设置菜单里，游戏设置-游戏-启用开发者控制台选是即可启用控制台，之后按下~即可开关控制台并使用各种指令。开启控制台的指令是con_enable 1，看起来是个悖论，等到说CFG时就知道它的用处了。 多个控制台指令当同时需要在控制台使用多个指令时，务必使用分号;分隔各个指令。 控制台提示指令输入的过程中控制台会给出提示，大多数情况都会有下拉菜单提示各种指令，可以使用↑↓在下拉菜单中切换，使用Tab键也可以自动填入下拉菜单的第一个指令，比如： 显示各种网络参数的指令net_graph 1，输入至net_时下方第一条指令就是net_graph，直接按下Tab和1即可快速输入这条完整的指令。 退出游戏的指令quit，原理同上，输入q→Tab→回车，即可实现光速quit（真实）。 不要小看提示，他可以很大程度上纠正拼写问题，有时使用指令&#x2F;CFG的时候可以试着手动输一遍，过程中提示消失很可能是拼写有误；同样，如果使用HLAE录制集锦，输入mirv发现没有提示极可能没有正确地使用HLAE启动CSGO。 常用控制台指令账号登录相关 quit 快速退出游戏，使用心态爆炸，光速quit exit 同上，不过没有那么有名 disconnect 退出服务器到主界面 retry 重连最近一次加入的房间，比如从休闲、死斗退出之后还想回到刚才的房间可以使用，前提是中途没有重开游戏；5e、b5等平台也可以使用快速重连服务器（小退），重启游戏是大退。 常用指令 net_graph 1 显示网络参数：ping&#x2F;var&#x2F;choke等，0为关闭。 net_graphpos 1 网络参数的水平位置：1&#x3D;右 2&#x3D;中 3&#x3D;左。 fps_max 300 设置最大帧数为300，一般会根据当前的帧数表现动态调整，尽可能让FPS波动不超过60以获得较好的观感体验。 volume 1 主音量大小，0为静音 sensitivity 0.9 鼠标灵敏度 map dust2 进入本地离线服务器并加载dust2地图，地图名不必完全一致，如荒漠迷城可以用map mir。 mat_monitorgamma 2.2 亮度，越小越亮[1.6~2.6] mat_monitorgamma_tv_enabled “0” 显示模式[1.电视 0.电脑屏幕] buy awp 购买武器指令，即购买awp give weapon_ak47 获得ak47，常用于跑图 +right 视角右移，输入-right取消 +moveright 相当于按下D键，-moveright取消，和+right组成挂机防踢指令 cl_相关参数cl_开头的指令往往和HUD有关，比如雷达、血条、菜单等用于提示玩家的信息。 cl_autowepswitch 0 关闭自动换上捡起的武器：珍爱生命，远离自动换枪 cl_autohelp 0 禁用游戏提示（格洛克&#x2F;法玛斯连发提示） cl_showhelp 0 禁用游戏提示 cl_dm_buyrandomweapons 0 关闭死斗随机买枪，功能同F3键 cl_draw_hud 0 关闭HUD，得到相对干净的画面，方便截图或者录制视频 cl_draw_only_deathnotices 0 关闭大部分HUD，保留准星和击杀信息，常用于录制视频和集锦 cl_drawhud_force_radar -1 强制关闭雷达，但是雷达下方的金钱数无法关闭，1开启雷达 HUD颜色透明度、雷达参数省略，直接在设置中调整即可。 准星参数 cl_crosshairalpha 255 透明度（0~255） cl_crosshairdot 1 准星中间的点，0关闭 cl_crosshairgap 1 十字准星间距，可以&lt;0 cl_crosshair_t 0 T型准星，1开启 cl_crosshairsize 3 准星长度 cl_crosshairthickness 1 准星厚度 cl_crosshairstyle 4 准星类型[1. 2. 3. 4.经典静态 5.跑动静止开枪动态] cl_crosshair_drawoutline 0 准星黑色外轮廓粗细，0关闭 cl_crosshaircolor_b “250” cl_crosshaircolor_r “0” cl_crosshaircolor_g “255” 准星的颜色RGB值 主要是这些参数，小改动使用控制台方便，更全面的调整请在创意工坊Crashz crosshair generator中调整。 持枪视角参数 viewmodel_presetpos 2 持枪视角预设[1.默认 2.写实 3.经典] viewmodel_recoil 0 取消开枪枪口向上跳动，1开启时跳动幅度很大 viewmodel_offset_x “1.1” viewmodel_offset_y “-1.8” viewmodel_offset_z “0.2” XYZ轴的参数 viewmodel_fov “54” 视角的FOV（视野大小） cl_bobcycle “0.98” 手臂摆动幅度 主要浏览一下这些参数，可以在创意工坊Crashz viewmodel generator中调整。 sv_相关参数sv是server的简写，一般在主机创建房间的时候使用，跑图常用。 sv_cheats 1 开启作弊模式，有的指令官匹会影响平衡，跑图时记得开启 sv_infinite_ammo 1 无限子弹 [1.无限子弹 2.无限弹夹数 0.关闭] sv_showimpacts 1 显示弹着点，0关闭 sv_showimpacts_time 15 弹着点时间，单位秒 sv_grenade_trajectory 1 显示投掷物轨迹，0关闭 sv_grenade_trajectory_time 15 投掷物轨迹显示时间 sv_grenade_trajectory_thickness 0.5 轨迹线厚度 bot相关指令 bot_kick 踢掉BOT bot_stop 1 BOT静止 bot_crouch 1 BOT蹲下 bot_add 添加BOT bot_kill 杀死BOT bot_place 放置BOT mp_相关指令 mp_warmup_end 热身结束 mp_restartgame 1 重新开始游戏 mp_freezetime 1 回合开始静止1s mp_round_restart_delay 2 回合结束后等待时间2s god 无敌，gods是所有人无敌 bind指令1bind x &quot;...&quot;; 该指令的格式如上，x为绑定的按键名，...是绑定的指令，可以是一条也可以是多条指令用分号;分开，填入引号&quot; &quot;，当指令是没有间隔的单独指令时引号;可以省略，其他情况不可省，如+speed可省略，sensitivity 1&#96;和多个指令不省略。多个指令例子如下： 1bind shift &quot;+speed;r_cleardecals&quot;; +speed是静步的指令，r_cleardecals是清楚血迹的指令，绑定了shift键。这条指令执行之后，在按下shift键静步的同时清除血迹。 bind指令还有一种用法，用来查看某个按键已经绑定的指令： 1bind x 输入之后控制台会显示已经绑定的指令，可以检查有没有正确地绑定按键。 unbind指令清除已绑定的键位，比如已经绑定了x键，想要取消： 1unbind x 1unbindall //取消所有按键绑定 1unbindallmousekeyboard//取消所有键鼠的绑定 bindtoggle和toggle指令有的指令比如cl_drawhud 1即打开HUD，修改数字得到cl_drawhud 0，即关闭HUD。实际这种指令往往在两个不同的值之间切换，那么使用bindtoggle和toggle就可以写出非常简单的一键切换的指令： 1bindtoggle x cl_drawhud; 1bind x &quot;toggle cl_drawhud&quot;; 这两种写法都可以实现x键切换HUD开关。 但是后者toggle的应用更广，可以触发切换更多的指令，比如： 1bind x &quot;toggle volume&quot;; 可以写成： 1bind x &quot;toggle volume 0 1&quot;; 但是实际上音量不仅有0、1两种情况，可以是0&#x2F;1之间的小数，同样有的指令的值可以大于1，这时候用第二种写法就可以任意地切换。 1bind x &quot;toggle volume 1 0.5&quot;; //一键切换音量100%/50% alias指令bind指令可以给某个键绑定指令，而alias指令则可以自定义指令。有了alias之后，可以实现CSGO中很多特殊的功能，可以了解一下一键高亮击杀 的指令解释。 1alias func &quot;...;...&quot;; 执行这条指令之后，在关闭CSGO游戏之前，使用func指令就相当于执行””中所有的指令，可以直接在控制台中使用： 1func 也可以绑定到某个按键上，按键触发： 1bind x func; 一定注意alias指令是临时生效的，重启游戏就要重新输入，解决办法是写成CFG并启用自动加载。 alias指令强大之处在于，它可以嵌套定义： 12345textalias f f_on;alias f_on &quot;alias f f_off;...&quot;;alias f_off &quot;alias f f_on;...&quot;;bind x f; 这样就实现一个开关式的功能： 一开始，按键x代表执行f，即f_on。 按下按键x，实际执行f_on，由于也执行了alias f f_of;，之后执行f相当于执行f_off 再按下按键x，实际执行f_off，由于也执行了alias f f_on;，之后执行f相当于执行f_on 往复在两个档位间切换 ...处可以放入各种指令，已经可以实现很多的功能了，下面给出跳投的指令： 123bind Capslock +jumpthrow; // &quot;Capslock&quot;键跳投 可修改alias +jumpthrow &quot;+jump;-attack&quot;;alias -jumpthrow -jump; 如果理解了刚才说的内容，这段指令应该可以理解，这里补充的是：+指令、-指令代表按下&#x2F;松开按键时触发，按下Capslock键执行+jump;-attack，也就是跳投，松开Capslock键执行-jump，防止不停地跳。 链接CSGO指令搜索 Valve官方指令清单 默认键位指令","categories":[],"tags":[{"name":"CS","slug":"CS","permalink":"https://ly-chen04.github.io/tags/CS/"}]},{"title":"更新日志","slug":"更新日志","date":"2023-03-23T02:00:00.000Z","updated":"2024-09-10T09:29:04.559Z","comments":true,"path":"2023/03/23/更新日志/","permalink":"https://ly-chen04.github.io/2023/03/23/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","excerpt":"欢迎访问什亭之箱","text":"欢迎访问什亭之箱 2024年9月5日 优化了一些细节 网站隐私政策更新 9月3日 网站使用全新设计语言重建 继续使用阿里云CDN加速服务 2月13日 删除了 大学英语语法总结 和 CSGO音乐盒原曲 两篇文章 网站CDN更换至阿里云服务 站点主体维护 更改了一些细节 2023年6月9日 更新日志 新增文章 CSGO音乐盒原曲 加入嵌入式第三方组件 3A415界面切块游戏回归 微调界面文字与布局 5月19日 更新日志 网站界面重构 网站接入CDN加速服务 优化网站整体体验 5月6日 更新日志 3A415页面临时改为Major 2023倒计时界面 (单击页面中的图片可跳转至主办方官网) 5月4日 更新日志 3A415界面更新彩蛋 (界面重写) 优化部分浏览体验 5月1日 更新日志 更改部分页面的背景图 在OBS——推流录制工具一文中插入若干图片 在全局底栏和文章页正文标题中加入渐变文字效果 4月28日 更新日志 新增文章：OBS-推流录制工具 更新文章：CSGO控制台指令简明索引 更改了部分文章的banner图片 4月27日 更新日志 新增文章：大学英语语法总结 更改主页图片 优化导航栏模糊效果 4月3日 更新日志 新增页面：3A415 简化顶部导航栏项目 4月2日更新日志 站点底部新增外部链接 新增全局中国标准时间校准 新增文章：更新日志 关于页面新增外部链接和图片 3月29日 更新日志 站点底部加入访问统计数据 新增文章：CSGO控制台指令简明索引 添加文章在首页展示的简略描述信息 新增文章页的数据统计 新增文章页的更新通知 3月27日 更新日志 新建 关于 页面 更改关于页面中的相关信息 新增站点顶栏毛玻璃模糊效果 3月24日 更新日志 更改站点全局主题 更改站点全局字体为系统UI字体 加入文章字数和浏览量统计 加入文章发布时间和作者署名 3月23日 更新日志 新建站点ChenHNSY.Gitee.io 更改站点标题为OYAMAMahiro 更改站点的归属权为OYAMAMahiro 更改站点首页文字 调快首页文字的出场速度","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"https://ly-chen04.github.io/tags/%E6%97%A5%E5%BF%97/"}]}],"categories":[],"tags":[{"name":"赛博说明书","slug":"赛博说明书","permalink":"https://ly-chen04.github.io/tags/%E8%B5%9B%E5%8D%9A%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"name":"网站信息公示","slug":"网站信息公示","permalink":"https://ly-chen04.github.io/tags/%E7%BD%91%E7%AB%99%E4%BF%A1%E6%81%AF%E5%85%AC%E7%A4%BA/"},{"name":"CS","slug":"CS","permalink":"https://ly-chen04.github.io/tags/CS/"},{"name":"技术","slug":"技术","permalink":"https://ly-chen04.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"日志","slug":"日志","permalink":"https://ly-chen04.github.io/tags/%E6%97%A5%E5%BF%97/"}]}